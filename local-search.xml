<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一些提高代码健壮性的方法</title>
    <link href="/2020/12/18/my-site-2/"/>
    <url>/2020/12/18/my-site-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载自 <a href="https://juejin.cn/post/6896118234391511053#heading-2">橙红年代</a></p></blockquote><p>在过去的开发经历中处理了各种奇葩BUG，认识到代码健壮性（鲁棒性）是衡量工作效率、生活质量一个非常重要的标准，本文主要整理了提高代码健壮性的一些思考。</p><h2 id="1-更安全地访问对象"><a href="#1-更安全地访问对象" class="headerlink" title="1. 更安全地访问对象"></a>1. 更安全地访问对象</h2><p>###1.1. 不要相信接口数据<br>不要相信前端传的参数，也不要信任后台返回的数据</p><p>比如某个api/xxx/list的接口，按照文档的约定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    code: <span class="hljs-number">0</span>,<br>    msg: <span class="hljs-string">&quot;&quot;</span>,<br>    data: [<br>     <span class="hljs-comment">// ... 具体数据</span><br>    ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>前端代码可能就会写成</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">const</span> &#123;code, msg, <span class="hljs-class"><span class="hljs-keyword">data</span>&#125; = await fetchList()</span><br><span class="hljs-class"><span class="hljs-keyword">data</span>.forEach(()=&gt;&#123;&#125;)</span><br><br></code></pre></td></tr></table></figure><p>因为我们假设了后台返回的<code>data</code>是一个数组，所以直接使用了<code>data.forEach</code>，如果在联调的时候遗漏了一些异常情况</p><ul><li><p>预期在没有数据时<code>data</code>会返回[]空数组，但后台的实现却是不返回<code>data</code>字段</p></li><li><p>后续接口更新，<code>data</code>从数组变成了一个字典，跟前端同步不及时</p></li></ul><p>这些时候，使用<code>data.forEach</code>时就会报错，</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Uncaught TypeError: <span class="hljs-keyword">data</span>.forEach is not a <span class="hljs-function"><span class="hljs-keyword">function</span></span><br></code></pre></td></tr></table></figure><p>所以在这些直接使用后台接口返回值的地方，最好添加类型检测</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Array</span>.isArray(<span class="hljs-class"><span class="hljs-keyword">data</span>) &amp;&amp; <span class="hljs-keyword">data</span>.forEach(()=&gt;&#123;&#125;)</span><br></code></pre></td></tr></table></figure><p>同理，后台在处理前端请求参数时，也应当进行相关的类型检测。</p><h3 id="1-2-空值合并运算符"><a href="#1-2-空值合并运算符" class="headerlink" title="1.2. 空值合并运算符"></a>1.2. 空值合并运算符</h3><p>由于JavaScript动态特性，我们在查询对象某个属性时如<code>x.y.z</code>，最好检测一下<code>x</code>和<code>y</code>是否存在</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">let z = <span class="hljs-symbol">x</span> &amp;&amp; <span class="hljs-symbol">x</span>.<span class="hljs-symbol">y</span> &amp;&amp; <span class="hljs-symbol">x</span>.<span class="hljs-symbol">y</span>.z<br></code></pre></td></tr></table></figure><p>经常这么写就显得十分麻烦，dart中安全访问对象属性就简单得多</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> z = a?.<span class="hljs-symbol">y</span>?.z;<br></code></pre></td></tr></table></figure><p>在ES2020中提出了空值合并运算符的草案，包括<code>??</code>和<code>?.</code>运算符，可以实现与dart相同的安全访问对象属性的功能。目前打开最新版Chrome就可以进行测试了</p><p><img src="http://img.shymean.com/oPic/1585982625374_463.png" alt="安全访问对象属性" title="安全访问对象属性"></p><p>在此之前，我们可以封装一个安全获取对象属性的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getObjectValueByKeyStr</span>(<span class="hljs-params">obj, key, defaultVal = <span class="hljs-literal">undefined</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!key) <span class="hljs-keyword">return</span> defaultVal;<br>    <span class="hljs-keyword">let</span> namespace = key.toString().split(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">let</span> value,<br>        i = <span class="hljs-number">0</span>,<br>        len = namespace.length;<br>    <span class="hljs-keyword">for</span> (; i &lt; len; i++) &#123;<br>        value = obj[namespace[i]];<br>        <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">undefined</span> || value === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> defaultVal;<br>        obj = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-keyword">var</span> x = &#123; <span class="hljs-attr">y</span>: &#123; <span class="hljs-attr">z</span>: <span class="hljs-number">100</span>,&#125;,&#125;;<br><br><span class="hljs-keyword">var</span> val = getObjectValueByKeyStr(x, <span class="hljs-string">&quot;y.z&quot;</span>);<br><span class="hljs-comment">// var val = getObjectValueByKeyStr(x, &quot;zz&quot;);</span><br><span class="hljs-built_in">console</span>.log(val);<br></code></pre></td></tr></table></figure><p>前端不可避免地要跟各种各种浏览器、各种设备打交道，一个非常重要的问题就是兼容性，尤其是目前我们已经习惯了使用ES2015的特性来开发代码，<code>polyfill</code>可以帮助解决我们大部分问题。</p><h2 id="2-记得异常处理"><a href="#2-记得异常处理" class="headerlink" title="2. 记得异常处理"></a>2. 记得异常处理</h2><p>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Control_flow_and_error_handling">JS错误处理 MDN</a></li><li><a href="https://www.cnblogs.com/laden666666/p/5281993.html">js构建ui的统一异常处理方案</a>，这个系列的文章写得非常好</li></ul><p>异常处理是代码健壮性的首要保障，关于异常处理有两个方面</p><ul><li>合适的错误处理可以提要用户体验，在代码出错时优雅地提示用户</li><li>将错误处理进行封装，可以减少开发量，将错误处理与代码解耦</li></ul><h3 id="2-1-错误对象"><a href="#2-1-错误对象" class="headerlink" title="2.1. 错误对象"></a>2.1. 错误对象</h3><p>可以通过throw语句抛出一个自定义错误对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Create an object type UserException</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserException</span> (<span class="hljs-params">message</span>)</span>&#123;<br>  <span class="hljs-comment">// 包含message和name两个属性</span><br>  <span class="hljs-built_in">this</span>.message=message;<br>  <span class="hljs-built_in">this</span>.name=<span class="hljs-string">&quot;UserException&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 覆盖默认[object Object]的toString</span><br>UserException.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;: &quot;&#x27;</span> + <span class="hljs-built_in">this</span>.message + <span class="hljs-string">&#x27;&quot;&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 抛出自定义错误</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UserException(<span class="hljs-string">&quot;Value too high&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> UserException)&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch UserException&#x27;</span>)<br>            <span class="hljs-built_in">console</span>.log(e)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;unknown error&#x27;</span>)<br>            <span class="hljs-keyword">throw</span> e<br>        &#125;<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>        <span class="hljs-comment">// 可以做一些退出操作，如关闭文件、关闭loading等状态重置</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;done&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span> <span class="hljs-comment">// 如果finally中return了值，那么会覆盖前面try或catch中的返回值或异常</span><br>    &#125;<br>&#125;<br>f()<br></code></pre></td></tr></table></figure><h3 id="2-2-同步代码"><a href="#2-2-同步代码" class="headerlink" title="2.2. 同步代码"></a>2.2. 同步代码</h3><p>对于同步代码，可以使用通过责任链模式封装错误，即当前函数如果可以处理错误，则在catch中进行处理：如果不能处理对应错误，则重新将catch抛到上一层</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;error b&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 当b能够处理异常时，则不再向上抛出</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        a()<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-keyword">if</span>(e === <span class="hljs-string">&#x27;error b&#x27;</span>)&#123;<br>            console.log(<span class="hljs-string">&#x27;由b处理&#x27;</span>)<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> e<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        b()<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        console.log(<span class="hljs-string">&#x27;顶层catch&#x27;</span>)<br>    &#125;<br>&#125;<br>### <span class="hljs-number">2.3</span>. 异步代码<br>由于<span class="hljs-keyword">catch</span>无法获取异步代码中抛出的异常，为了实现责任链，需要把异常处理通过回调函数的方式传递给异步任务<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span><span class="hljs-params">(errorHandler)</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;error a&quot;</span>);<br>    <span class="hljs-keyword">if</span> (errorHandler) &#123;<br>        errorHandler(error);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> error;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span><span class="hljs-params">(errorHandler)</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> handler = e =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (e === <span class="hljs-string">&quot;error b&quot;</span>) &#123;<br>            console.log(<span class="hljs-string">&quot;由b处理&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            errorHandler(e);<br>        &#125;<br>    &#125;;<br><br>    setTimeout(() =&gt; &#123;<br>        a(handler);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">let</span> globalHandler = e =&gt; &#123;<br>    console.log(e);<br>&#125;;<br>b(globalHandler);<br></code></pre></td></tr></table></figure><h3 id="2-4-Prmise的异常处理"><a href="#2-4-Prmise的异常处理" class="headerlink" title="2.4. Prmise的异常处理"></a>2.4. Prmise的异常处理</h3><p>Promise只包含三种状态：<code>pending</code>、<code>rejected</code>和<code>fulfilled</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">let</span> promise2 = promise1.then(<span class="hljs-literal">on</span>Fulfilled, <span class="hljs-literal">on</span>Rejected)<br></code></pre></td></tr></table></figure><p>下面是<code>promise</code>抛出异常的几条规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">case1</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 如果promise1是rejected态的，但是onRejected返回了一个值（包括undifined），那么promise2还是fulfilled态的，这个过程相当于catch到异常，并将它处理掉，所以不需要向上抛出。</span><br>    <span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;p1 error&#x27;</span><br>    &#125;)<br><br>    p1.then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;, <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(e)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">a</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">// 如果注册了onReject，则不会影响后面Promise执行</span><br>        <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 收到的是2</span><br>    &#125;)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">case2</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//  在promise1的onRejected中处理了p1的异常，但是又抛出了一个新异常，，那么promise2的onRejected会抛出这个异常</span><br>    <span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;p1 error&#x27;</span><br>    &#125;)<br>    p1.then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;, <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(e)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;error in p1 onReject&#x27;</span><br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">a</span>)=&gt;</span>&#123;&#125;, <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">// 如果p1的 onReject 抛出了异常</span><br>        <span class="hljs-built_in">console</span>.log(e)<br>    &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">case3</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 如果promise1是rejected态的，并且没有定义onRejected，则promise2也会是rejected态的。</span><br>    <span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;p1 error&#x27;</span><br>    &#125;)<br><br>    p1.then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">a</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;not run:&#x27;</span>, a)<br>    &#125;, <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">// 如果p1的 onReject 抛出了异常</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;handle p2:&#x27;</span>, e)<br>    &#125;)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">case4</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// // 如果promise1是fulfilled态但是onFulfilled和onRejected出现了异常，promise2也会是rejected态的，并且会获得promise1的被拒绝原因或异常。</span><br>    <span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        resolve(<span class="hljs-number">1</span>)<br>    &#125;)<br>    p1.then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(res)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;p1 onFull error&#x27;</span><br>    &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;&#125;, <span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;handle p2:&#x27;</span>, e)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">123</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们可以在<code>onRejected</code>中处理当前<code>promise</code>的错误，如果不能，就把他抛给下一个<code>promise</code></p><h3 id="2-5-async"><a href="#2-5-async" class="headerlink" title="2.5. async"></a>2.5. async</h3><p><code>async/await</code>本质上是promise的语法糖，因此也可以使用<code>promise.catch</code>类似的捕获机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">cb, cb2 =()=&gt;&#123;&#125;,ms = <span class="hljs-number">100</span></span>) </span>&#123;<br>    cb2()<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                cb();<br>                resolve();<br>            &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>                reject(e)<br>            &#125;<br>        &#125;, ms);<br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 通过promise.catch来捕获</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">case1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">await</span> sleep(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;sleep reject error&quot;</span>;<br>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(e);<br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 通过try...catch捕获</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">case2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">await</span> sleep(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;sleep reject error&quot;</span>;<br>        &#125;)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;catch:&quot;</span>, e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 如果是未被reject抛出的错误，则无法被捕获</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">case3</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">await</span> sleep(<span class="hljs-function">()=&gt;</span>&#123;&#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 抛出一个未被promise reject的错误</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;no reject error&#x27;</span><br>        &#125;).catch(<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cannot catch:&#x27;</span>, e)<br>        &#125;)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;catch:&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-更稳定的第三方模块"><a href="#3-更稳定的第三方模块" class="headerlink" title="3. 更稳定的第三方模块"></a>3. 更稳定的第三方模块</h2><p>在实现一些比较小功能的时候，比如日期格式化等，我们可能并不习惯从npm找一个成熟的库，而是自己顺手写一个功能包，由于开发时间或者测试用例不足，当遇见一些未考虑的边界条件，就容易出现BUG。</p><p>这也是npm上往往会出现一些很小的模块，比如这个判断是否为奇数的包：<code>isOdd</code>，周下载量居然是60来万。</p><p><img src="http://img.shymean.com/oPic/1585919200512_881.png" alt="isOdd" title="isOdd"></p><p>使用一些比较成熟的库，一个很重要原因是，这些库往往经过了大量的测试用例和社区的考验，肯定比我们顺手些的工具代码更安全。</p><p>一个亲身经历的例子是：根据UA判断用户当前访问设备，正常思路是通过正则进行匹配，当时为了省事就自己写了一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOSType</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> ua = navigator.userAgent<br><br>  <span class="hljs-keyword">const</span> isWindowsPhone = <span class="hljs-regexp">/(?:Windows Phone)/</span>.test(ua)<br>  <span class="hljs-keyword">const</span> isSymbian = <span class="hljs-regexp">/(?:SymbianOS)/</span>.test(ua) || isWindowsPhone<br>  <span class="hljs-keyword">const</span> isAndroid = <span class="hljs-regexp">/(?:Android)/</span>.test(ua)<br><br>  <span class="hljs-comment">// 判断是否是平板</span><br>  <span class="hljs-keyword">const</span> isTablet =<br>    /(?:iPad|PlayBook)/.test(ua) ||<br>    (isAndroid &amp;&amp; !<span class="hljs-regexp">/(?:Mobile)/</span>.test(ua)) ||<br>    (<span class="hljs-regexp">/(?:Firefox)/</span>.test(ua) &amp;&amp; <span class="hljs-regexp">/(?:Tablet)/</span>.test(ua))<br><br>  <span class="hljs-comment">// 是否是iphone</span><br>  <span class="hljs-keyword">const</span> isIPhone = <span class="hljs-regexp">/(?:iPhone)/</span>.test(ua) &amp;&amp; !isTablet<br><br>  <span class="hljs-comment">// 是否是pc</span><br>  <span class="hljs-keyword">const</span> isPc = !isIPhone &amp;&amp; !isAndroid &amp;&amp; !isSymbian &amp;&amp; !isTablet<br>  <span class="hljs-keyword">return</span> &#123;<br>    isIPhone,<br>    isAndroid,<br>    isSymbian,<br>    isTablet,<br>    isPc<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上线后发现某些小米平板用户的逻辑判断出现异常，调日志看见UA为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Linux; U; Android <span class="hljs-number">8</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>; zh-CN; MI PAD <span class="hljs-number">4</span> Build/OPM<span class="hljs-number">1</span>.<span class="hljs-number">171019</span>.<span class="hljs-number">019</span>) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Version/<span class="hljs-number">4</span>.<span class="hljs-number">0</span> Chrome/<span class="hljs-number">57</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2987</span>.<span class="hljs-number">108</span> Quark/<span class="hljs-number">3.8.5.129</span> Mobile Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span><br></code></pre></td></tr></table></figure><p>即使把MI PAD添加到正则判断中临时修复一下，万一后面又出现其他设备的特殊UA呢？所以，凭借自己经验写的很难把所有问题都考虑到，后面替换成 <a href="https://www.npmjs.com/package/mobile-detect">mobile-detect</a> 这个库。</p><p>使用模块的缺点在于</p><p>可能会增加文件依赖体积，增加打包时间等，这个问题可以通过打包配置解决，将不会经常变更的第三方模块打包到<code>vendor</code>文件中配置缓存<br>在某些项目可能会由于安全考虑需要减少第三方模块的使用，或者要求先进行源码<code>code review</code><br>当然在进行模块选择的时候也要进行各种考虑，包括稳定性、旧版本兼容、未解决<code>issue</code>等问题。当选择了一个比较好的工具模块之后，我们就可以将更多的精力放在业务逻辑中。</p><h2 id="4-本地配置文件"><a href="#4-本地配置文件" class="headerlink" title="4. 本地配置文件"></a>4. 本地配置文件</h2><p>在开发环境下，我们可能需要一些本地的开关配置文件，这些配置只在本地开发时存在，不进入代码库，也不会跟其他同事的配置起冲突。</p><p>我推崇将mock模板托管到git仓库中，这样可以方便其他同事开发和调试接口，带来的一个问题时本地可能需要一个引入mock文件的开关</p><p>下面是一个常见的做法：新建一个本地的配置文件config.local.js，然后导出相关配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// config.local.js</span><br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  needMock: <span class="hljs-keyword">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>记得在<code>.gitignore</code>中忽略该文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.local</span><span class="hljs-selector-class">.js</span><br></code></pre></td></tr></table></figure><p>然后通过<code>try...catch...</code>加载该模块，由于文件未进入代码库，在其他地方拉代码更新时会进入<code>catch</code>流程，本地开发则进入正常模块引入流程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// mock/entry.js</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; needMock &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./config.local&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (needMock) &#123;<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./index&#x27;</span>) <span class="hljs-comment">// 对应的mock入口</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;====start mock api===&#x27;</span>)<br>  &#125;<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;未引入mock，如需要，请创建/mock/config.local并导出 &#123;needMock: true&#125;&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在整个应用的入口文件判断开发环境并引入</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">process.env.NODE_ENV</span> === <span class="hljs-string">&#x27;development&#x27;</span>) &#123;<br>  <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;../mock/entry&#x27;</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，就可以在本地开发时愉快地进行各种配置，而不必担心忘记在提交代码前注释对应的配置修改~</p><h2 id="5-Code-Review"><a href="#5-Code-Review" class="headerlink" title="5. Code Review"></a>5. Code Review</h2><p>参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/xoekgWhWDK6GioKq0OFI1A">Code Review 是苦涩但有意思的修行</a></li></ul><p><code>Code Review</code>应该是是上线前一个必经的步骤，我认为CR主要的作用有</p><ul><li><p>能够确认需求理解是否出现偏差，避免扯皮</p></li><li><p>优化代码质量，包括冗余代码、变量命名和过分封装等，起码除了写代码的人之外还得保证审核的人能看懂相关逻辑</p></li></ul><p>对于一个需要长期维护迭代的项目而言，每一次<code>commit</code>和<code>merge</code>都是至关重要的，因此在合并代码之前，最好从头检查一遍改动的代码。即使是在比较小的团队或者找不到审核人员，也要把合并认真对待。</p><ol start="6"><li>小结<br>本文主要整理了提高<code>JavaScript</code>代码健壮性的一些方法，主要整理了</li></ol><ul><li>安全地访问对象属性，避免数据异常导致代码报错</li><li>捕获异常，通过责任链的方式进行异常处理或上报</li><li>使用更稳定更安全的第三方模块，</li><li>认真对待每一次合并，上线前先检查代码</li></ul><p>此外，还需要要养成良好的编程习惯，尽可能考虑各种边界情况。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>健壮性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开篇</title>
    <link href="/2020/12/18/my-site-1/"/>
    <url>/2020/12/18/my-site-1/</url>
    
    <content type="html"><![CDATA[<h2 id="意志不纯正，则学识足以为害。-——柏拉图"><a href="#意志不纯正，则学识足以为害。-——柏拉图" class="headerlink" title="意志不纯正，则学识足以为害。 ——柏拉图"></a>意志不纯正，则学识足以为害。 ——柏拉图</h2>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
